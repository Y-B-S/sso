# SSO 方案说明 #

------------------------------------------------------------------------
## SSO 登录原理 ##

>  SSO (Single Sign ON)，中文名称为单点登录，用于帮助用户在多个相互信任的系统应用中只需登录一次便可使用所有的应用，省去用户多次登录的麻烦。

> 比如在这样一种场景中：现在有两个app,分别为app1和app2，在未使用SSO系统的情况下，用户要使用app1和app2时只能分别在app1和app2上进行登录。在有SSO系统的情况下，用户在第一次进行登录时，不论此时用户登录的是app1还是app2，都会跳转到SSO认证系统。SSO认证用户为无效用户时，用户登录失败。SSO认证用户为有效用户时，此时SSO认证系统便会发给用户一个唯一的认证凭证--ticket，这时候用户访问另一个app时，会将这个ticket也发送至SSO认证系统，SSO对这个ticket进行验证，验证成功后，用户便可直接使用这个app而不需要再进行一次登录。

>由上面的场景中可以看出SSO有如下的条件：

> 1. 所有app应用都需要访问SSO系统进行用户登录认证;
> 2. 所有app应用都能够识别和提取ticket信息;
> 3. 所有app应用都能够识别用户的登录状态;

>以上3点是SSO系统所要实现的基本内容。

------------------------------------------------------------------------
## SSO 实现 ##

> SSO的实现是基于cookie的。SSO系统发送的ticket本质上是要写到cookie中。用户使用应用进行登录时，即要写应用所在域的cookie也要写SSO域的cookie。用户登录一个应用app后再使用另一个域的app时，还是要通过SSO进行判断是否已经登录，在已经登录过的情况下只需要添加这个app应用的域上的cookie到客户端浏览器。

> SSO主要的实现过程可以归结为以下步骤：

> 1. 所有的用户账号信息要全部提取到同一个域（SSO服务所在域）的数据库中（或使用文件方式），用户登录的验证及信息提取全部由这个SSO系统控制进行。
> 2. app应用可保留原来的登录页面但app应用本身不再进行登录验证，用户登录验证部分都会经app系统跳转至SSO系统进行。
> 3. 若在SSO域内没有找到用户登录凭证（ticket），则SSO会转到SSO域内的登录页面要求用户进行登录。用户登录成功后，用户浏览器会写SSO域内的cookie再跳转到app页面写app域内的cookie，最后由app应用返回用户最初请求的页面，app所使用的用户信息也应全部由SSO系统返回。
> 4. 当用户已经登录某一app应用后再尝试使用另一个需要登录验证的app应用时，这个app会将用户转到SSO系统，此时用户访问SSO会使用SSO域内的ticket（cookie），并且SSO知道用户是由该app跳转而来，SSO判断用户为已经登录并跳回原app。跳回时queryString中会添加ticket信息，那么app便知道用户已经得到验证，便会置用户为已登录状态并写自身域的cookie，最后返回用户请求的页面。
> 5. 用户在已登录的情况下进行登出时，app首先跳转到SSO进行登出操作，收回ticket凭证，消除用户在SSO域内的登录状态，然后SSO使用户跳回app，app清除自身域内的用户登录状态，用户便在该app域和SSO域都为登出状态
> 6. 其它app在用户的每一次请求时都经SSO检查用户的登录状态，若SSO判定用户已登出时，app应立即置自身域内用户状态为登出状态，并将用户置于自身域内的登录页面。除每次用户请求动作之外，每个app还应该以固定频率询问SSO用户的登录状态

------------------------------------------------------------------------
## SSO 中需要考虑的问题 ##

*  数据存储问题

>   SSO所要解决的是用户登录的问题，当用户登录一个app后，便在多个app应用中进行了登录，此时如果用户使用了多个app，那么一旦用户登出一个app后，此时便登出了所有的app。比如Google便是如此。

> 当用户数量很大时，SSO系统如何保存ticket登录凭证。目前的做法有两种选择：

> 1. 直接存取文件（数据库）
2. 存取于内存块中

>  这两种做法有各自的优点和缺点。存取数据库其实相当于存取硬盘。数据库可以存取的数据量基本上不受限制远远大于内存空间，内存的优点在于速度上很快。

> php 中用户登录验证过程一般是通过客户端浏览器上的cookie和服务端的session来实现的。而cookie和session实际上都是存储于文件中的。cookie一般由客户端浏览器来保存，不在控制范围。事实上上面所说的ticket凭证的两种存取方式其实也指的是session的存储方式。session 的存储便成为解决SSO用户登录效率问题的重点。一般来说session会存储在文件中，这样当session文件比较多时，session文件的检索便成为一个问题。对于这个问题一般的做法有两种：

> 1. session 文件分级（session.save_path="N;/save_path"， //N为分级级数）
> 2. 将session文件存储于数据库中

> 首先需要说明，文件系统检索文件的速度快于数据库管理系统检索数据库的速度，这两种方案其实是用来应对session文件不同数量等级的。session文件分级只不过是将session文件分在了多个文件夹之中，速度上其实还是和原来的文件存储方式一样。将session存储在数据库中唯一的好处其实是数据量不受限制，牺牲的是速度。

> 上面将session存储在文件或数据库中的做法都有各自所适用的场合，关于文件、分组文件以及数据库这三种做法具体的session文件数量临界值需要进行更进一步的测试才能得知。

> 对于session文件数量巨大而又对反应速度要求比较高的应用中，就要考虑另一种做法了。比如使用memcached，redis 等内存数据库等。这种解决方案即可以提高系统反应速度又能突破session文件数量的限制，还可以解决多服务器共享的问题，是大型系统的一种优秀解决方案。不过要求系统要安装这种服务并保障该服务正常的运行（否则PHP可能挂掉），而且所有的文件者存储在memory中，对于持久化来说需要另行考虑了。

> 以上考虑的ticket（session）的存储方式，需要根据项目的实际情况而定。影响的因素主要是数据量（文件量）和反应速度要求，另外持久化和数据共享也是需要考虑的因素。

* session有效期设置
> 使用 memcache 时，对于session的有效期设置就不仅要考虑到session和cookie本身的有效期设置，还要考虑到memcache中数据的有效期了。



*  cookie跨域问题
> 由于SSO是基于cookie来实现的，而cookie是不能够跨域的，因此SSO的认证也存在跨域的问题。可以考虑按域数量而采取不同的模型解决跨域问题。
> 当域不多时，一般少于三个，可以采取后台跳转的方式。
 比如，当有两个域时，www.domain1.com, www.domain2.com, 用户登录domain1.com时，会跳转到SSO系统进行用户验证，这时可以设置用户浏览器上的domain1.com的cookie。而在omain2.com
上的cookie未能设置，这时用户即使登录domain2.com也会处于未登录状态。解决这个问题的关键在于要在用户登录domain1.com时为用户设置domain2.com的cookie。解决办法是：

>   1.  用户请求 domain1.com 的一个页面，此时浏览器没有domain1和domain2的验证cookie
2.  domain1验证用户，如合法便设置该用户为登录，同时set_cookie并发送response
3.  response并未返回给用户浏览器而是重定向到domain2.com的一个页面，现时存储用户请求的domain1 URL
4.  domain2.com的这个页面，设置用户为登录domain2状态，并发送响应给用户浏览器
5.  用户浏览器设置domain2的验证cookie，并请求domain2上的一个页面，此时用户浏览器只有domain2上面的验证cookie
6.  domain2上的这个页面会重定向到domain1上，同时发送的还有之前存储的domain1 URL
7.  domain1上用户的状态已被置为登录，domain1返回响应给用户浏览器
8.  用户浏览器设置domain1的验证cookie，此时用户浏览器上有domain1和domain2的验证cookie
9.  用户浏览器重新请求domain1的页面
10. domain1正常返回用户请求页面，这时用户浏览器上面有domain1和domain2的验证cookie，用户请求domain2时，浏览器会发送属于domain2的cookie，用户不再需要进行登录。

> 这个模型可以使用的场合是：
1.  域比较少，一般不应该多于3个
2.  每个域需要清楚其它域的登录细节

>    上面的模型在只有两三个域时可行，当存在很多域时，实现过程将会变得很复杂。所以当存在很多域时，需要考虑采用其它的模型。 在存在很多域时，可以采用以下的登录方式，在这种情况下，需要有一个专门处理登录的域，假设为 sso.com。

>  1.  用户请求 domain1.com 的一个需要验证的页面
2.  domain1.com 会重定向请求到 sso.com，并保存用户请求的domain1.com的页面URL至rtnURL中
3.  sso.com验证用户是否有验证ticket（cookie）存在，如果没有ticket存在，则跳转到 domain1.com的登录页面，queryString 中存有rtnURL
4.  domain1.com得知用户来自sso.com，且知用户没有sso.com的验证cookie，所以跳转到domain1.com的登录页面
5.  用户通过 sso.com 提供的接口进行用户登录的验证，成功后颁发一个ticket给用户，此时用户在domain1.com上便成功登录，再将包含ticket的URL跳转至sso.com
6.  sso.com这时可以得知用户有ticket，但是没有用户验证cookie，说明用户已经从domain1.com登录，此时要设置sso.com验证cookie
7.  sso.com设置验证cookie，将cookie添加至response中加上ticket按照rtnURL地址返回
8.  浏览器跳转domain1.com，此时有了sso.com的验证cookie，存储该验证cookie，并请求domain1.com
9.  domain1.com检查ticket，返回用户请求页面

> 这时如果用户要登录domain2.com时，

> 1.  浏览器会跳转sso.com，设置rtnURL
2.  因为浏览器有sso.com的验证cookie，所以会将这个cookie一并发给sso.com
3.  sso.com会测验证这个cookie，若cookie没有过期，则在queryString中添加ticket按rtnURL返回
4.  domain2.com发现有ticket，说明用户已经通过验证，这时返回用户请求页面

> 这种模型比较适合于具有很多个域时采用。

*  单点注销
> 以上考虑的都是登录的实现，对于单点登出即注销同样可能存在一此需要解决的问题。用户在domain1.com下登出时，要同时对sso.com的cookie进行过期设置或无效设置。那么就要保证用户民在每一次的登录验证时都要访问sso.com，以使登出的用户在每一个域的页面请求时都能得到用户最新的登录状态。

> 1.  用户在domain1.com进行登出操作
2.   浏览器跳转至 sso.com 进行登出
3.   用户浏览器的sso.com验证cookie被置为无效或过期
4.   跳回domain1.com进行登出，设置用户在domain1.com的cookie 为无效或过期
5.   用户登出完成

* Cookie 丢失问题
> 若用户有domain1下的cookie ticket，但没有SSO下的cookie，那么用户是否应该被置为登录状态？这个问题可以统一设置为，没有SSO域下的验证cookie的用户都应该被置为未登录状态。

--------
##流程说明：
> 1. 用户在app1登录，登录页面在app1，登录提交页面在SSO login.php 页面。SSO login.php 页面判断用户是否为有效用户，是则颁发ticket（session和cookie）然后转回到app1，app1 然后写自己域的cookie置用户为登录状态。若SSO login.php 页面判断用户为非有效用户（通过用户名和密码组合），则同样返回app1，此时 app1 页面应提醒用户相关错误信息。
> 2. 用户在使用app2时，因为之前已经有了app1的登录，这时应直接登录app2。当然是否登录要通过SSO进行判断。



